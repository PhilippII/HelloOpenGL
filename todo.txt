GLFW:
- also install glfw3-wayland?
- glfw version 3.2.1 too old? (website recommends >= 3.3.2)
	-> compile GLFW from source instead?
- static vs. dynamic linking against glfw and glew. which is better?
	-> and why does pkg-config --libs --static not include -Wl,-Bstatic -Wl,-Bdynamic ?

c++-stdlib:
- use ios_base::sync_with_stdio(false) to improve performance?
- use path instead of string?
	-> e.g. for platform independent filename separator ( '/' vs '\' )

OpenGL:
- GLCall(...) macro is fragile
	-> e.g. 
		if (...)
			GLCall(x());
		if (...)
			GLClearError();
			x();
			myAssert(GLLocCall(...))
		-> x() is not part of the if's body anymore!!
- std::array 
	-> is std::array guaranteed to allow copy construction of new arrays?
		-> also if array to be copied from is a line of a 2D-array?
	-> and is it guaranteed to have the same memory layout as a normal C-style array?

GLShaderProgram:
- also cache vertex attribute locations (similar to the uniform locations)
	-> how to avoid making getAttribLocation(...) non-const?


VertexBufferLayout:
- add templated versions of the other overloads of append(..) as well
	-> maybe add helper-function/variable-template/whatever that converts
		OpenGL types to their corresponding GLenum constant
		(How does this work?)


abstraction into classes me vs. cherno:
- generally:
	-> cherno: debug utils are in same header as class Renderer
	-> cherno: Bind() and Unbind() are const
- ShaderProgram
	-> cherno: ShaderProgram only called Shader
	-> me: separate classes for Shader and ShaderProgram
	-> cherno: also contains parsing function and directly accepts filename in constructor	
	-> cherno: it is not possible to create a Shader without immediately compiling/linking it in the constructor already



abstracting into classes other TODOs:
- ShaderProgram should not link before compiling and co.


removed differences me vs. cherno:
- generally
	-> cherno: member variables are prefixed with m_
	-> cherno: ids of OpenGL-Objects are called m_RendererID
- Buffers
	- cherno: VertexBuffer and IndexBuffer are separate classes
- BufferLayout
	-> append takes componentType as template argument rather than as regular function argument
	-> cherno: there is an actual class for the BufferLayout which contains VertexBufferElements
	-> me: there is only a std::vector of VertexAttributeType (=VertexBufferElement)
- GLMesh + VAO
	-> cherno: there is no GLMesh class that takes care of vao, BufferLayout and vbo simultanously
	-> cherno: but the vao-class itself also takes a BufferLayout and a reference to the vbo
	-> cherno: vao-class still does not take a reference to an ibo
	-> cherno: vao-class still does not create vbo by itself it merely takes it as a function 
		argument to function AddBuffer(...)
- ShaderProgram:
	-> cherno: glUseProgram(..) is called Bind()
- Renderer
	-> me: separate renderer class does not exist: glDrawElements(...) is called from main(..) function directly


DONE:
- which of those functions do I need to call again for every frame when rendering multiple
	3D-models (each from its own buffer)
	- glBindBuffer(...) ?
	- glEnableVertexAttribArray(...) ?
	- glVertexAttribPointer(...) ?
	-> and is the situation different when using glDrawArray(...) (no index buffer)
		vs. when using glDrawElements(...) (with index buffer)
	-> answer depends on whether we use Vertex Array Objects
		see video 12 Vertex Arrays in OpenGL
- clean up vertex buffers and co. at the end of the program
	-> destructors take care of that
- in assignment operator do delete previous content if there is any!!
- after reading chapters 9 + 10 in stroustrup look again at function ParseShader(...)
- rename getName to getRendererID()
- compile with gcc specific macro  -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC
	-> and what do those do?: -D_GLIBCXX_CONCEPT_CHECKS 
		-> I don't know I added a comment line to the makefile to remind me
			I might consider looking this up and maybe use it
	-> what happens if I compile with -D_GLIBCXX_DEBUG but link against a library
		that was compiled without -D_GLIBCXX_DEBUG?
		-> from my experiment (with *.o files instead of libraries) it seems to give a linker error



