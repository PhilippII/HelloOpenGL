\documentclass{article}

\usepackage{amsmath} % align*-environment
\usepackage{amssymb} % e.g. \mathbb{R}
\usepackage{amsthm} % newtheorem

\usepackage{hyperref}

\newtheorem{lemma}{Lemma}

\newcommand{\R}{\mathbb{R}}
\newcommand{\vctr}[1]{\mathbf{#1}}
\newcommand{\point}[1]{\mathbf{#1}}
\newcommand{\nrml}[1]{\mathbf{#1}}

\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\pMat}[2]{\mat{P_{#1 \leftarrow #2}}}
\newcommand{\vMat}[2]{\mat{V_{#1 \leftarrow #2}}}
\newcommand{\nMat}[2]{\mat{N_{#1 \leftarrow #2}}}

\newcommand{\tangent}{\vctr{t}}
\newcommand{\bitangent}{\vctr{b}}
\newcommand{\normal}{\nrml{n}}

\newcommand{\colvec}[1]{\begin{pmatrix}#1\end{pmatrix}}
\newcommand{\rowvec}[1]{\begin{pmatrix}#1\end{pmatrix}}

\newcommand{\matCol}[1]{\vctr{a_{#1}}}

\DeclareMathOperator{\adj}{adj}

\begin{document}

overview:
\begin{itemize}
 \item intro/motivation
 \item normal matrices in general
 \begin{itemize}
 \item how to compute the inverse matrix with the adjoint method and with the cross products
 \item why do we need to use the inverse transpose when transforming normals
 \end{itemize}
 \item how to transform from tangent space to world space
 \begin{itemize}
 \item define tangent space coordinates of \(\point{p}\) (and define point \(\point{p_\perp}\))
 \item barycentric coordinates and how to transform point \(\point{p_\perp}\) from its uv-coordinates to object space
 \item how to transform points \(\point{p}\) from tangent space to object space
 \item how to transform vectors and normals from tangent space to object space
 \item interpolating the normal matrices
 \end{itemize}
 \item preprocessing the normals in tangent space: 
 \begin{itemize}
  \item unpack normals from \([0, 1]^3\) to \([-1, 1]^3\)
  \item flip v-axis if necessary (inverse transpose is the same)
  \item scale tangent space along the normal direction (inverse transpose divides by scale factor)
 \end{itemize}

\end{itemize}

\newpage
\title{Transforming Normals from Tangent Space to World Space
in a Mathematically Accurate Way}
\author{Philipp Schoch}
\maketitle
\tableofcontents
\newpage

\section{Introduction}

As you probably know in computer graphics we often use \(4\times 4\) matrices to describe (affine) transformations. Given such a matrix \(\mat{M} \in \R^{4\times 4}\) we can transform points as:
\[
\colvec{\point{q} \\ 1} = \mat{M} \colvec{\point{p} \\ 1}
\]
where \(\point{p}\) is the original point and \(\point{q}\) is the transformed point. Vectors can be transformed similarly as 
\[
\colvec{\vctr{u} \\ 0} = \mat{M} \colvec{\vctr{v} \\ 0}
\]

Or alternatively we can just use the upper \(3\times 3\) submatrix \(\mat{\tilde{M}}\) of \(\mat{M}\) as
\[
\vctr{u} = \mat{\tilde{M}}\vctr{v}
\]

However normals need to be handled differently. Instead of this submatrix \(\mat{\tilde{M}}\) \emph{we need to use the inverse transpose of this submatrix \(\mat{\tilde{M}}\) to transform normals}. (Also it may be necessary to renormalize the normal after the transformation, that is to divide it by its length.) Books and tutorials about computer graphics usually mention the fact that normals need to be handled differently this way in the context of the model-view matrix when transforming normals between object space, world space and camera space. \emph{However this fact is often swept under the rug when transforming normals defined in a normal map from tangent space to object space or world space.} 

There is a situation when taking the inverse transpose is not necessary. It is when the columns of \(\mat{M}\) are an ortho\textbf{norm}al basis, that is they are all mutually perpendicular to each other and they each are of length one. Confusingly such a matrix is called an ortho\textbf{gon}al matrix although the expression "ortho\textbf{norm}al matrix" would make more sense. Equivalently we can say a matrix is orthogonal if it contains only rotations and optionally a mirroring transform. If \(\mat{M}\) is an orthogonal matrix then the inverse transpose is equal to \(\mat{M}\) itself. 

So in the defense of those tutorials, that do not mention the inverse transpose in the context of normal mapping, could we assume that the transformation from tangent space to object space is always an orthogonal matrix? No, tangent space is defined by the tangent vector \(\tangent\), bitangent vector \(\bitangent\) and the normal vector \(\normal\). The tangent and bitangent vectors are defined such that they align with the \(u\) and \(v\) axis in texture coordinate space respectively. However how they look in world space depends on the uv-map that is used to wrap the textures around the mesh. However we cannot expect the artist to define the uv-map in a way such that the tangent and bitangent vectors are always normalized and perpendicular to each other. That would mean we cannot allow any stretching, squishing or shearing of the texture by the uv-map. This is un unrealistic restriction. 

Another approach that is sometimes used is to artificially "orthonormalize" the vectors \(\tangent\), \(\bitangent\) and \(\normal\). That is instead of the actual tangent and bitangent  \(\tangent\) and \(\bitangent\) we use two different vectors \(\tilde{\tangent}\) and \(\tilde{\bitangent}\), which are normalized and perpendicular to each other but which are still tangent to the surface. Maybe we also make sure that \(\tilde{\tangent}\) points in the same direction as \(\tangent\). But then \(\tilde{\bitangent}\) has to point into a different direction than \(\bitangent\) in order to be perpendicular to \(\tilde{\tangent}\). However this approach does not make sense to me either. Imagine if we were to use such an approach for the model-view matrix \(\mat{M}\). Say we orthonormalize the columns of the upper \(3\times 3\) submatrix \(\mat{\tilde{M}}\) yielding a different matrix \(\mat{\tilde{A}}\). Now we use \(\mat{\tilde{A}}\) to transform both vectors and normals. While that way the transformation of vectors and normals would be compatible with each other our 3D-model would undergo a completely different transformation. For example any shearing of the original matrix \(\mat{\tilde{M}}\) would be lost. The best we can hope for is that any rotation, translation and mirroring transform contained in \(\mat{M}\) is preserved. I think this shows how absurd the idea is to "orthonormalize" a transformation matrix in order to avoid having to compute the inverse transpose for transforming normals.

The fact that the usage of the inverse transpose is not explained properly in most resources on normal mapping bothers me.
Therefore I wanted to discuss in this document how I think that normals from a normal map could be transformed in a mathematically accurate way.

However in practice when using a normal map it is important for compatibility to use the exact same conventions as the application that baked the normal map. This is probably actually more important than mathematical accuracy. However I still wanted to focus on mathematical accuracy first with this document to understand how it should be done in theory first, before making compromises in practice. Furthermore my approach may be better suited in a case where the normal map was not baked for a specific 3D-model but is more of a stock texture that we have bought online and that we have then wrapped around our own model maybe in a repeating tiling pattern.

\section{Transforming Normals}

\subsection{Matrix Inversion using the Adjugate Matrix and Cross Products}

Imaginary Task:

Given:
\begin{itemize}
\item Matrix: \(\mat{A} := (\matCol{1}, \matCol{2}, \matCol{3}) \in \R^{3\times 3}\)
\item Vectors: \(\vctr{v_1}:= \colvec{v_{x, 1} \\ v_{y, 1} \\ v_{z, 1}}, \vctr{v_2}:= \colvec{v_{x, 2} \\ v_{y, 2} \\ v_{z, 2}}, \dots, \vctr{v_n}:= \colvec{v_{x, n} \\ v_{y, n} \\ v_{z, n}}\)
\end{itemize}

Task:

compute \(\det(\matCol{1}, \matCol{2}, \vctr{v_1}), \det(\matCol{1}, \matCol{2}, \vctr{v_2}), \dots, \det(\matCol{1}, \matCol{2}, \vctr{v_n})\)

Solution:

Expand along third column:
\begin{align*}
\det(\matCol{1}, \matCol{2}, \vctr{v_i}) &= 
\begin{vmatrix}
a_{11} & a_{12} & v_{x, i} \\
a_{21} & a_{22} & v_{y, i} \\
a_{3Â´1} & a_{32} & v_{z, i}
\end{vmatrix} \\
&= \begin{vmatrix}
a_{21} & a_{22} \\
a_{31} & a_{32}
\end{vmatrix} v_{x, i}
- \begin{vmatrix}
a_{11} & a_{12} \\
a_{31} & a_{32}
\end{vmatrix} v_{y, i}
+ \begin{vmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{vmatrix} v_{z, i}
\end{align*}

To speed up the calculation we can precompute the factors that are the same for each \(\vctr{v_i}\) and cache them in a rowvector.
\begin{align*}
\vctr{r_3}^T := \rowvec{r_{x, 3} & r_{y, 3} & r_{z, 3}} := 
\rowvec{
\begin{vmatrix}
a_{21} & a_{22} \\
a_{31} & a_{32}
\end{vmatrix} &
- \begin{vmatrix}
a_{11} & a_{12} \\
a_{31} & a_{32}
\end{vmatrix} &
\begin{vmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{vmatrix}}
\end{align*}

Now each determinant can be computed as:
\begin{align*}
\det(\matCol{1}, \matCol{2}, \vctr{v_i}) = \vctr{r_3}^T \vctr{v_i}
\end{align*}

Now imagine a different task where we want to compute the determinants \(\det(\matCol{1}, \vctr{v_1}, \matCol{3}), \det(\matCol{1}, \vctr{v_2}, \matCol{3}), \dots, \det(\matCol{1}, \vctr{v_n}, \matCol{3})\).

This time we can expand along the second column:
\begin{align*}
\det(\matCol{1}, \matCol{2}, \vctr{v_i}) &= 
\begin{vmatrix}
a_{11} & v_{x, i} & a_{13} \\
a_{21} & v_{y, i} & a_{23} \\
a_{31} & v_{z, i} & a_{33} 
\end{vmatrix} \\
&= -\begin{vmatrix}
a_{21} & a_{23} \\
a_{31} & a_{33}
\end{vmatrix} v_{x, i}
+ \begin{vmatrix}
a_{11} & a_{13} \\
a_{31} & a_{33}
\end{vmatrix} v_{y, i}
- \begin{vmatrix}
a_{11} & a_{13} \\
a_{21} & a_{23}
\end{vmatrix} v_{z, i}
\end{align*}

Again we can precompute the common factors and cache them in a rowvector:
\begin{align*}
\vctr{r_2}^T := \rowvec{r_{x, 2} & r_{y, 2} & r_{z, 2}} := 
\rowvec{
-\begin{vmatrix}
a_{21} & a_{23} \\
a_{31} & a_{33}
\end{vmatrix} &
+ \begin{vmatrix}
a_{11} & a_{13} \\
a_{31} & a_{33}
\end{vmatrix}
- \begin{vmatrix}
a_{11} & a_{13} \\
a_{21} & a_{23}
\end{vmatrix}}
\end{align*}

Then we can compute the determinants as:
\begin{align*}
\det(\matCol{1}, \vctr{v_i}, \matCol{3}) = \vctr{r_2}^T \vctr{v_i}
\end{align*}

And last but not least assume we want to compute the determinants: 

\(\det(\vctr{v_1}, \matCol{2}, \matCol{3}), \det(\vctr{v_2}, \matCol{2}, \matCol{3}), \dots, \det(\vctr{v_n}, \matCol{2}, \matCol{3})\).

We expand along the first column:
\begin{align*}
\det(\matCol{1}, \matCol{2}, \vctr{v_i}) &= 
\begin{vmatrix}
v_{x, i} & a_{12} & a_{13} \\
v_{y, i} & a_{22} & a_{23} \\
v_{z, i} & a_{32} & a_{33}
\end{vmatrix} \\
&= \begin{vmatrix}
a_{22} & a_{23} \\
a_{32} & a_{33}
\end{vmatrix} v_{x, i}
- \begin{vmatrix}
a_{12} & a_{13} \\
a_{32} & a_{33}
\end{vmatrix} v_{y, i}
+ \begin{vmatrix}
a_{12} & a_{13} \\
a_{22} & a_{23}
\end{vmatrix} v_{z, i}
\end{align*}

And precompute the common factors and cache them in a rowvector:
\begin{align*}
\vctr{r_1}^T &:= \rowvec{r_{x, 1} & r_{y, 1} & r_{z, 1}} \\
&:= 
\rowvec{
\begin{vmatrix}
a_{22} & a_{23} \\
a_{32} & a_{33}
\end{vmatrix} &
- \begin{vmatrix}
a_{12} & a_{13} \\
a_{32} & a_{33}
\end{vmatrix}
\begin{vmatrix}
a_{12} & a_{13} \\
a_{22} & a_{23}
\end{vmatrix}}
\end{align*}

Then we can compute the determinants as:
\begin{align*}
\det(\vctr{v_i}, \matCol{2}, \matCol{3}) = \vctr{r_1}^T \vctr{v_i}
\end{align*}

Having completed this task we may notice that the auxiliary vectors \(\vctr{r_1}^T, \vctr{r_2}^T\) and \(\vctr{r_3}^T\) are useful for another task as well. Namely computing the inverse matrix of \(\mat{A}\). Assume we collect those three auxiliary vectors into a \(3\times 3\) matrix and than multiply this matrix with the original matrix \(\mat{A}\):


\begin{align*}
\begin{pmatrix}
\vctr{r_1}^T\\
\vctr{r_2}^T\\
\vctr{r_3}^T
\end{pmatrix} 
\begin{pmatrix}
\matCol{1} & \matCol{2} & \matCol{3}
\end{pmatrix}
&= 
\begin{pmatrix}
\vctr{r_1}^T\matCol{1} & \vctr{r_1}^T\matCol{2} & \vctr{r_1}^T\matCol{3}\\
\vctr{r_2}^T\matCol{1} & \vctr{r_2}^T\matCol{2} & \vctr{r_2}^T\matCol{3}\\
\vctr{r_3}^T\matCol{1} & \vctr{r_3}^T\matCol{2} & \vctr{r_3}^T\matCol{3}
\end{pmatrix}\\
&= 
\begin{pmatrix}
\det(\matCol{1}, \matCol{2}, \matCol{3}) & \det(\matCol{2}, \matCol{2}, \matCol{3}) & \det(\matCol{3}, \matCol{2}, \matCol{3})\\
\det(\matCol{1}, \matCol{1}, \matCol{3}) & \det(\matCol{1}, \matCol{2}, \matCol{3}) & \det(\matCol{1}, \matCol{3}, \matCol{3})\\
\det(\matCol{1}, \matCol{2}, \matCol{1}) & \det(\matCol{1}, \matCol{2}, \matCol{2}) & \det(\matCol{1}, \matCol{2}, \matCol{3})
\end{pmatrix}
\end{align*}



\begin{align*}
\begin{pmatrix}
\vctr{r_1}^T\\
\vctr{r_2}^T\\
\vctr{r_3}^T
\end{pmatrix} \mat{A} &= 
\begin{pmatrix}
\det(\mat{A}) & 0 & 0\\
0 & \det(\mat{A}) & 0\\
0 & 0 & \det(\mat{A})
\end{pmatrix}
\end{align*}

\begin{align*}
\adj(\mat{A}) := \begin{pmatrix}
\vctr{r_1}^T\\
\vctr{r_2}^T\\
\vctr{r_3}^T
\end{pmatrix}
\end{align*}


This implies:
\begin{align*}
\left(\frac{1}{\det(\mat{A})}\adj(\mat{A})\right)\mat{A} &= \frac{1}{\det(\mat{A})}\left(\adj(\mat{A})\mat{A}\right)\\
&=\frac{1}{\det(\mat{A})}\begin{pmatrix}
\det(\mat{A}) & 0 & 0\\
0 & \det(\mat{A}) & 0\\
0 & 0 & \det(\mat{A})
\end{pmatrix}\\
&= \begin{pmatrix}
1& 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{pmatrix}
\end{align*}

Thus:
\begin{align*}
\frac{1}{\det(\mat{A})}\adj(\mat{A}) = \mat{A}^{-1}
\end{align*}

This approach for matrix inversion works for matrices of any size. However for bigger matrices it is probably inefficient in practice. And only in the case of \(3 \times 3\) matrices there is a particularly nice notation for the vectors \(\vctr{r_1}^T, \vctr{r_2}^T, \vctr{r_3}^T\) in terms of the cross product.

For example:
\begin{align*}
\vctr{r_3}^T = (\matCol{1} \times \matCol{2})^T
\end{align*}

This may be surprising because the cross product is usually not introduced as "an auxiliary vector to compute the determinant as a function of the third column". Instead the cross product \(\vctr{u} \times \vctr{v}\) of two vectors \(\vctr{u}\) and \(\vctr{v}\) is usually defined as a vector with the following properties (see \href{http://immersivemath.com/ila/ch04_vectorproduct/ch04.html#sec_vp_definition}{immersive math}):
\begin{itemize}
\item \(\vctr{u} \times \vctr{v}\) is orthogonal to the plane spanned by \(\vctr{u}\) and \(\vctr{v}\)
\item the length of \(\vctr{u} \times \vctr{v}\) is equal to the area of the parellelogram spanned by \(\vctr{u}\) and \(\vctr{v}\)
\item \(\vctr{u}, \vctr{v}\) and \(\vctr{u} \times \vctr{v}\) form a right handed coordinate system (= are positively oriented)
\end{itemize}



\subsection{Why Normals should be Transformed with the Inverse Transpose}

\begin{lemma}
Let \(\mat{M} \in \R^{3\times 3}\) be an invertible matrix. And let \(\vctr{a}, \vctr{b} \in \R^3\). Then
\[
(\mat{M}\vctr{a})\times(\mat{M}\vctr{b}) = \adj(\mat{M}) (\vctr{a} \times \vctr{b})
\]
\end{lemma}
\begin{proof}
 ...
\end{proof}


\section{Transforming from Tangent Space to Object Space}

\subsection{Definition of Tangent Space Coordinates}
For points \(\point{p}\) that are not necessarily located on the surface we want to define tangent space coordinates. Let \(\point{p_\perp}\) be the point that we get by perpendicularly projecting \(\point{p}\) onto the triangle. We define the first two coordinates of the tangent space coordinates of \(\point{p}\) to be the uv-texture coordinates of \(\point{p_\perp}\). And the third tangent space cooordinate of \(\point{p}\) shall be the signed distance \(d\) of \(\point{p}\) from the triangle.
\begin{equation*}
 \point{p_{tc}} := \colvec{u \\ v \\ d}
\end{equation*}

\subsection{barycentric coordinates}

\[
\point{p} = \lambda_0 \point{p_0} + \lambda_1 \point{p_1} + \lambda_2 \point{p_2}
\]
where \(\lambda_0 + \lambda_1 + \lambda_2 = 1\).

Plugging in \(\lambda_0 = 1 - \lambda_1 - \lambda_2\):
\begin{align*}
%p &= (1 - \lambda_1 - \lambda_2) p_0 + \lambda_1 p_1 + \lambda_2 p_2 \\
\point{p} &= \point{p_0} - \lambda_1 \point{p_0} - \lambda_2 \point{p_0}  + \lambda_1 \point{p_1} + \lambda_2 \point{p_2} \\
&= \point{p_0}  + \lambda_1 (\point{p_1}-\point{p_0}) + \lambda_2 (\point{p_2} - \point{p_0})\\
&= \point{p_0} + \lambda_1 \point{\Delta p_1} + \lambda_2 \point{\Delta p_2}
\end{align*}

where
\begin{align*}
\point{\Delta p_1} &:= \point{p_1} - \point{p_0}\\
\point{\Delta p_2} &:= \point{p_2} - \point{p_0}
\end{align*}

Thus
\[
 \colvec{\point{p}\\1} = \pMat{oc}{bc} \colvec{\lambda_1 \\ \lambda_2 \\ 1}
\]
where
\begin{equation}
\label{eq:mat_oc_from_bc}
 \pMat{oc}{bc} := \begin{pmatrix} 
                  \point{\Delta p_1} & \point{\Delta p_2} & \point{p_0} \\
                  0 & 0 & 1
                 \end{pmatrix}
\end{equation}


\subsection{Transforming from Texture Coordinates to Object Space}

Similar to equation (\ref{eq:mat_oc_from_bc}) we can construct a matrix to transform from (the last two components of) barycentric coordinates to texture coordinates
\[
 \colvec{u \\ v \\1} = \pMat{uv}{bc} \colvec{\lambda_1 \\ \lambda_2 \\ 1}
\]
where
\begin{equation}
 \pMat{uv}{bc} := \begin{pmatrix} 
                  \Delta u_1 & \Delta u_2 & u_0 \\
                  \Delta v_1 & \Delta v_2 & v_0 \\
                  0 & 0 & 1
                 \end{pmatrix}
\end{equation}
where
\begin{align*}
 \colvec{\Delta u_1 \\ \Delta v_1} := \colvec{u_1 \\ v_1} - \colvec{u_0 \\ v_0}\\
 \colvec{\Delta u_2 \\ \Delta v_2} := \colvec{u_2 \\ v_2} - \colvec{u_0 \\ v_0}
\end{align*}

By taking a detour through barycentric coordinates we can now also transform points from texture coordinates to object coordinates.
\begin{equation*}
\colvec{\point{p}\\1} = \pMat{oc}{uv} \colvec{u \\ v \\1} 
\end{equation*}
where
\begin{equation*}
 \pMat{oc}{uv} := \pMat{oc}{bc}(\pMat{uv}{bc}^{-1}) 
\end{equation*}




\subsection{Transforming Points from Tangent Space to Object Space}
\begin{align*}
 \point{p} &= \point{p_\perp} + d \vctr{n}\\
 &= \point{p_0} + \lambda_1 \point{\Delta p_1} + \lambda_2 \point{\Delta p_2} + d \vctr{n}
\end{align*}

Thus
\[
 \colvec{\point{p}\\1} = \pMat{oc}{(bc+d)} \colvec{\lambda_1 \\ \lambda_2 \\ d \\ 1}
\]
where
\begin{equation}
\label{eq:mat_oc_from_bdc}
 \pMat{oc}{(bc+d)} := \begin{pmatrix} 
                  \point{\Delta p_1} & \point{\Delta p_2} & \vctr{n} & \point{p_0} \\
                  0 & 0 & 0 & 1
                 \end{pmatrix}
\end{equation}

\[
 \colvec{u \\ v \\ d \\1} = \pMat{(uv+d)}{(bc+d)} \colvec{\lambda_1 \\ \lambda_2 \\ d \\ 1}
\]
where
\begin{equation}
 \pMat{(uv+d)}{(bc+d)} := \begin{pmatrix} 
                  \Delta u_1 & \Delta u_2 & 0 & u_0 \\
                  \Delta v_1 & \Delta v_2 & 0 & v_0 \\
                  0 & 0 & 1 & 0 \\
                  0 & 0 & 0 & 1
                 \end{pmatrix}
\end{equation}

\begin{equation*}
\colvec{\point{p}\\1} = \pMat{oc}{tc} \colvec{u \\ v \\ d \\ 1} 
\end{equation*}
where
\begin{equation*}
 \pMat{oc}{tc} := \pMat{oc}{(bc+d)}(\pMat{(uv+d)}{(bc+d)}^{-1}) 
\end{equation*}

\subsection{Transforming Normals from Tangent Space to Object Space}

Lets first see how to transform vectors:
\begin{equation*}
 \vMat{oc}{tc} := \vMat{oc}{(bc+d)}(\vMat{(uv+d)}{(bc+d)}^{-1}) 
\end{equation*}
where
\begin{equation}
\label{eq:vmat_oc_from_bdc}
 \vMat{oc}{(bc+d)} := \begin{pmatrix} 
                  \point{\Delta p_1} & \point{\Delta p_2} & \vctr{n} 
                 \end{pmatrix}
\end{equation}

\begin{equation}
 \vMat{(uv+d)}{(bc+d)} := \begin{pmatrix} 
                  \Delta u_1 & \Delta u_2 & 0 \\
                  \Delta v_1 & \Delta v_2 & 0 \\
                  0 & 0 & 1 
                 \end{pmatrix}
\end{equation}

\begin{align*}
\nMat{oc}{tc} &:= (\vMat{oc}{(bc+d)}^{-1})^T(\vMat{(uv+d)}{(bc+d)}^T) \\
  &= \frac{1}{(\point{\Delta p_1} \times \point{\Delta p_2)}\cdot \vctr{n}}\begin{pmatrix} 
        \point{\Delta p_2} \times \vctr{n} & \vctr{n} \times \point{\Delta p_1} & \point{\Delta p_1} \times \point{\Delta p_2}
     \end{pmatrix}
     \begin{pmatrix} 
                  \Delta u_1 & \Delta v_1 & 0 \\
                  \Delta u_2 & \Delta v_2 & 0 \\
                  0 & 0 & 1 
     \end{pmatrix}
\end{align*}

\subsection{Interpolating the Normal Matrices}

\section{Preprocessing Steps}

\end{document}
